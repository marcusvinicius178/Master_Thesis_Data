#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Nov  5 15:51:43 2021

@author: autoware-auto-ros1
"""

from Power_Consumption_Astar_Mechanic_Energy import *
from Power_Consumption_Lattice_Mechanic_Energy import *
#For the public road a new module was created, because the first one needed to drop too much lines to synchronize with the DF that informed the Posex and Y on timestamp. Therefore this drop was not good to return a faithful behavior for acceleration, jerk, smoothness that need all the points of trajectory for do not affect the result, this does not happen with Power calculated by force because the Deltax,y will be bigger in droped positions due Timestamp synhcronization 
from Power_Consumption_Public_Road_Mechanic_Energy import *
from Power_Consumption_OP_Mechanic_Energy import *
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy import stats
import pandas as pd


Jerk_xy_Op = Acceleration_xy_df_Op['Acceleration XY'] / Acceleration_xy_df_Op['Delta Time']
Jerk_xy_Lattice =  Acceleration_xy_df_Lattice['Acceleration XY'] / Acceleration_xy_df_Lattice['Delta Time']
Jerk_xy_Astar = Acceleration_xy_df_Astar['Acceleration XY'] / Acceleration_xy_df_Astar['Delta Time']
Jerk_xy_Public_Road = Acceleration_xy_df_Public_Road['Acceleration XY'] / Acceleration_xy_df_Public_Road['Delta Time']

Jerk_xy_Op_df = pd.DataFrame({'Jerk':Jerk_xy_Op})
Jerk_xy_Lattice_df = pd.DataFrame({'Jerk':Jerk_xy_Lattice})
Jerk_xy_Astar_df = pd.DataFrame({'Jerk':Jerk_xy_Astar})
Jerk_xy_Public_Road_df = pd.DataFrame({'Jerk':Jerk_xy_Public_Road})
#Required to filter the outliers

#Using IQR - Open Planner
Q1_op = Jerk_xy_Op_df[["Jerk"]].quantile(0.25)
Q3_op = Jerk_xy_Op_df[["Jerk"]].quantile(0.75)
IQR_op = Q3_op - Q1_op
Filtered_Jerk_Op = Jerk_xy_Op_df[~((Jerk_xy_Op_df < (Q1_op - 1.5 * IQR_op)) |(Jerk_xy_Op_df > (Q3_op + 1.5 * IQR_op))).any(axis=1)]
#Lattice
Q1_Lattice = Jerk_xy_Lattice_df[["Jerk"]].quantile(0.25)
Q3_Lattice = Jerk_xy_Lattice_df[["Jerk"]].quantile(0.75)
IQR_Lattice = Q3_Lattice - Q1_Lattice
Filtered_Jerk_Lattice = Jerk_xy_Lattice_df[~((Jerk_xy_Lattice_df < (Q1_Lattice - 1.5 * IQR_Lattice)) |(Jerk_xy_Lattice_df > (Q3_Lattice + 1.5 * IQR_Lattice))).any(axis=1)]
#Astar
Q1_Astar = Jerk_xy_Astar_df[["Jerk"]].quantile(0.25)
Q3_Astar = Jerk_xy_Astar_df[["Jerk"]].quantile(0.75)
IQR_Astar = Q3_Astar - Q1_Astar
Filtered_Jerk_Astar = Jerk_xy_Astar_df[~((Jerk_xy_Astar_df < (Q1_Astar - 1.5 * IQR_Astar)) |(Jerk_xy_Astar_df > (Q3_Astar + 1.5 * IQR_Astar))).any(axis=1)]
#Pubic Road
Q1_Public_Road = Jerk_xy_Public_Road_df[["Jerk"]].quantile(0.25)
Q3_Public_Road = Jerk_xy_Public_Road_df[["Jerk"]].quantile(0.75)
IQR_Public_Road = Q3_Public_Road - Q1_Public_Road
Filtered_Jerk_Public_Road = Jerk_xy_Public_Road_df[~((Jerk_xy_Public_Road_df < (Q1_Public_Road - 1.5 * IQR_Public_Road)) |(Jerk_xy_Public_Road_df > (Q3_Public_Road + 1.5 * IQR_Public_Road))).any(axis=1)]



#It is not possible to compare the TOTAL value of Smoothness for these planners, taking the
#"official equation" which is Smoothness = Σ Jerk²  Because the planners differs in Number of Waypoints
#therefore the planners that produced more waypoints, will consequently present the higher smoothness value,
#for this reason the mean/median of jerk must be taken and Smoothnes = Jerk_mean² 
f, axs = plt.subplots(1,2,
                      figsize=(9,5),
                      sharey=True)


Op_average_jerk = Filtered_Jerk_Op.mean() #Filtered_Jerk_Op.sum()
Lattice_average_jerk = Filtered_Jerk_Lattice.mean() #Filtered_Jerk_Lattice.sum()
Astar_average_jerk = Filtered_Jerk_Astar.mean()#Filtered_Jerk_Astar.sum()
Public_Road_average_jerk = Filtered_Jerk_Public_Road.mean() #Filtered_Jerk_Public_Road.sum()

#THE NUMBER OF WAYPOINTS GENERATED BY PUBLIC ROAD TO CREATE THE TRAJECTORY IN INFINITE LESS TO
#AUTOWARE PATH PLANNERS, THAN THE SUM OF THE VALUES WILL BE SIGNIFICATIVLY HIGHER. THAT IS WHY IS NEEDED TO TAKE THE AVERAGE.
'''
Op_jerk_sum = Filtered_Jerk_Op.sum()
Lattice_jerk_sum = Filtered_Jerk_Lattice.sum()
Astar_jerk_sum = Filtered_Jerk_Astar.sum()
Pubic_Road_jerk_sum = Filtered_Jerk_Public_Road.sum()
'''


Smoothness_Op = Op_average_jerk #(Jerk_xy_Op.pow(2)).sum()
Smoothness_Lattice = Lattice_average_jerk # (Jerk_xy_Lattice.pow(2)).sum()
Smoothness_Astar = Astar_average_jerk #(Jerk_xy_Astar.pow(2)).sum()
Smoothness_Public_Road = Public_Road_average_jerk #(Jerk_xy_Public_Road.pow(2)).sum()

smoothness_list = [Smoothness_Astar['Jerk'], Smoothness_Lattice['Jerk'], Smoothness_Op['Jerk'], Smoothness_Public_Road['Jerk']]
min_smoothness = min(smoothness_list)


Data_Dictionary = {'A*':Smoothness_Astar['Jerk'], 'Lattice':Smoothness_Lattice['Jerk'], 'Op':Smoothness_Op['Jerk'] ,'Public_Road':Smoothness_Public_Road['Jerk'] }
data_items = Data_Dictionary.items()
data_List = list(data_items)
Planners_Smoothness_Df = pd.DataFrame(data_List)
Planners_Smoothness_Df.columns = ["Trajectory Planners", "Smoothness of Trajectory"]
 

sns.set_theme(style="whitegrid")
ax = sns.barplot( x= "Trajectory Planners", y= "Smoothness of Trajectory" , 
                 data = Planners_Smoothness_Df,
                 palette=['Black', 'Red', 'Green', 'Blue'],
                 orient= 'v',ax=axs[0])

ax.bar_label(ax.containers[0])

ax.set(ylabel='Smoothness of Trajectory (m⁴/s¹⁶)')

#HIGHER VALUES OF SMOOTHNESS REPRESENT MORE VIBRATION, MORE JERK DURING THE VEHICLE'S EXECUTION. 
#THEREFORE THE WORST SMOOTHNESS TRAJECTORY WAS FOR A* ALGORITHM, ONCE HAD BIGGER ACCELERATION RATES, LATER
#THE OP THAT HAS ALSO PERFORMED A HIGH LATERAL DISPLACEMENT IN SHORT TIME. THEN LATTICE THAT OSCILLATED A LOT, BUT DID NOT CHANGE ACCELERATION
#ABRUPTALLY...AND FINALLY PUBLIC ROAD WAS THE MOST SMOOTHER, AS THE TRAJECTORY PROFILE SHOWS.




#-------Second Plot--------------------------------------------------------------------------
#Percentage Factor = How much LESS SMOOTHER IS THE VALUE COMPARED TO THE MORE SMOOTHER = MINIMUM VALUE
Inv_Factor_Smoothness_Op = min_smoothness / Smoothness_Op['Jerk'] *100
Inv_Factor_Smoothness_Lattice = min_smoothness / Smoothness_Lattice['Jerk'] *100
Inv_Factor_Smoothness_Astar = min_smoothness / Smoothness_Astar['Jerk'] *100
Inv_Factor_Smoothness_Public_Road = min_smoothness / Smoothness_Public_Road['Jerk'] *100


Data_Dictionary_inv = {'A*':Inv_Factor_Smoothness_Astar, 'Lattice':Inv_Factor_Smoothness_Lattice, 'Op':Inv_Factor_Smoothness_Op, 'Public_Road':Inv_Factor_Smoothness_Public_Road }
data_items_inv = Data_Dictionary_inv.items()
data_List_inv = list(data_items_inv)
Planners_Inv_Smoothness_Df = pd.DataFrame(data_List_inv)
Planners_Inv_Smoothness_Df.columns = ["Trajectory Planners", "Inverse Smoothness Factor (%)"]
#HIGHER VALUES OF SMOOTHNESS REPRESENT MORE VIBRATION, MORE JERK DURING THE VEHICLE'S EXECUTION. 
#THEREFORE THE WORST SMOOTHNESS TRAJECTORY WAS FOR A* ALGORITHM, ONCE HAD BIGGER ACCELERATION RATES, LATER
#THE OP THAT HAS ALSO PERFORMED A HIGH LATERAL DISPLACEMENT IN SHORT TIME. THEN LATTICE THAT OSCILLATED A LOT, BUT DID NOT CHANGE ACCELERATION
#ABRUPTALLY...AND FINALLY PUBLIC ROAD WAS THE MOST SMOOTHER, AS THE TRAJECTORY PROFILE SHOWS... 

sns.set_theme(style="whitegrid")
ax = sns.barplot( x= "Trajectory Planners", y= "Inverse Smoothness Factor (%)" , 
                 data = Planners_Inv_Smoothness_Df,
                 palette=['Black', 'Red', 'Green', 'Blue'],
                 orient= 'v',ax=axs[1])

#ax.set(ylabel='Smoothness of Trajectory (m⁴/s¹⁶')


ax.bar_label(ax.containers[0])